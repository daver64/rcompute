#version 430
layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, r32ui) uniform uimage2D accumImage;

uniform uint seed;
uniform int samplesPerInvocation;
uniform int maxIterations;
uniform int minIterations;
uniform vec2 viewMin;
uniform vec2 viewMax;

const int MAX_STEPS = 1024;

uint pcg_hash(uint v)
{
    v ^= v >> 16;
    v *= 0x7feb352du;
    v ^= v >> 15;
    v *= 0x846ca68bu;
    v ^= v >> 16;
    return v;
}

float rand01(inout uint state)
{
    state = pcg_hash(state);
    return float(state) * (1.0 / 4294967296.0);
}

void sample_orbit(inout uint rng)
{
    vec2 c = vec2(
        mix(viewMin.x, viewMax.x, rand01(rng)),
        mix(viewMin.y, viewMax.y, rand01(rng))
    );

    vec2 z = vec2(0.0);
    vec2 orbit[MAX_STEPS];
    int stepCount = 0;
    int limit = min(maxIterations, MAX_STEPS);

    for (; stepCount < limit; ++stepCount) {
        orbit[stepCount] = z;

        float x = z.x * z.x - z.y * z.y + c.x;
        float y = 2.0 * z.x * z.y + c.y;
        z = vec2(x, y);

        if (dot(z, z) > 4.0) {
            ++stepCount; // include the escaping step
            break;
        }
    }

    if (dot(z, z) <= 4.0)
        return; // did not escape

    if (stepCount < minIterations)
        return; // filter out short orbits that add noise

    ivec2 size = imageSize(accumImage);
    vec2 span = viewMax - viewMin;

    for (int i = 0; i < stepCount; ++i) {
        vec2 p = orbit[i];
        float u = (p.x - viewMin.x) / span.x;
        float v = (p.y - viewMin.y) / span.y;

        if (u < 0.0 || u >= 1.0 || v < 0.0 || v >= 1.0)
            continue;

        ivec2 coord = ivec2(u * float(size.x), v * float(size.y));
        coord = clamp(coord, ivec2(0), size - ivec2(1));
        imageAtomicAdd(accumImage, coord, 1u);
    }
}

void main()
{
    uint state = seed
        + uint(gl_GlobalInvocationID.x) * 747796405u
        + uint(gl_GlobalInvocationID.y) * 2891336453u;

    for (int i = 0; i < samplesPerInvocation; ++i) {
        sample_orbit(state);
        state += 0x9e3779b9u; // decorrelate between samples
    }
}
